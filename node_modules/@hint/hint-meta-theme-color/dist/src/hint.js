"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const color_string_1 = require("color-string");
const utils_types_1 = require("@hint/utils-types");
const utils_string_1 = require("@hint/utils-string");
const utils_compat_data_1 = require("@hint/utils-compat-data");
const meta_1 = require("./meta");
const i18n_import_1 = require("./i18n.import");
class MetaThemeColorHint {
    constructor(context) {
        let bodyElementWasReached = false;
        let firstThemeColorMetaElement;
        const checkIfThemeColorMetaElementWasSpecified = (event) => {
            const pageDOM = context.pageDOM;
            const { resource } = event;
            const linksToManifest = pageDOM.querySelectorAll('link[rel="manifest"]').length > 0;
            if (!firstThemeColorMetaElement && linksToManifest) {
                context.report(resource, (0, i18n_import_1.getMessage)('metaElementNotSpecified', context.language), { severity: utils_types_1.Severity.warning });
            }
        };
        const isNotSupportedColorValue = (color, normalizedColorValue) => {
            const hexWithAlphaRegex = /^#([0-9a-fA-F]{4}){1,2}$/;
            return (color.model === 'rgb' &&
                hexWithAlphaRegex.test(normalizedColorValue) &&
                !(0, utils_compat_data_1.isSupported)({ property: 'color', value: '#00000000' }, context.targetedBrowsers)) ||
                color.model === 'hwb';
        };
        const checkContentAttributeValue = (resource, element) => {
            const contentValue = element.getAttribute('content');
            const normalizedContentValue = (0, utils_string_1.normalizeString)(contentValue, '');
            const color = (0, color_string_1.get)(normalizedContentValue);
            if (color === null) {
                const message = (0, i18n_import_1.getMessage)('metaElementInvalidContent', context.language);
                context.report(resource, message, {
                    element,
                    severity: utils_types_1.Severity.error
                });
                return;
            }
            if (isNotSupportedColorValue(color, normalizedContentValue)) {
                const message = (0, i18n_import_1.getMessage)('metaElementUnsupported', context.language);
                context.report(resource, message, {
                    element,
                    severity: utils_types_1.Severity.error
                });
            }
        };
        const checkNameAttributeValue = (resource, element) => {
            const nameAttributeValue = element.getAttribute('name');
            if (nameAttributeValue && nameAttributeValue !== nameAttributeValue.trim()) {
                const message = (0, i18n_import_1.getMessage)('metaElementInvalidName', context.language);
                context.report(resource, message, {
                    element,
                    severity: utils_types_1.Severity.warning
                });
            }
        };
        const validate = ({ element, resource }) => {
            if ((0, utils_string_1.normalizeString)(element.getAttribute('name')) !== 'theme-color') {
                return;
            }
            if (firstThemeColorMetaElement) {
                context.report(resource, (0, i18n_import_1.getMessage)('metaElementDuplicated', context.language), {
                    element,
                    severity: utils_types_1.Severity.warning
                });
                return;
            }
            firstThemeColorMetaElement = element;
            if (bodyElementWasReached) {
                context.report(resource, (0, i18n_import_1.getMessage)('metaElementInBody', context.language), {
                    element,
                    severity: utils_types_1.Severity.error
                });
                return;
            }
            checkNameAttributeValue(resource, element);
            checkContentAttributeValue(resource, element);
        };
        context.on('element::meta', validate);
        context.on('element::body', () => {
            bodyElementWasReached = true;
        });
        context.on('traverse::end', checkIfThemeColorMetaElementWasSpecified);
    }
}
exports.default = MetaThemeColorHint;
MetaThemeColorHint.meta = meta_1.default;
